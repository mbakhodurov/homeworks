import addFormats from 'ajv-formats';
import Ajv from '@redocly/ajv/dist/2020.js';
import { escapePointerFragment } from '../ref-utils.js';
let ajvInstance = null;
export function releaseAjvInstance() {
    ajvInstance = null;
}
function getAjv(resolve) {
    if (!ajvInstance) {
        ajvInstance = new Ajv({
            schemaId: '$id',
            meta: true,
            allErrors: true,
            strictSchema: false,
            inlineRefs: false,
            validateSchema: false,
            discriminator: true,
            allowUnionTypes: true,
            validateFormats: true,
            loadSchemaSync(base, $ref, $id) {
                const decodedBase = decodeURI(base.split('#')[0]);
                const resolvedRef = resolve({ $ref }, decodedBase);
                if (!resolvedRef || !resolvedRef.location)
                    return false;
                return {
                    $id: encodeURI(resolvedRef.location.source.absoluteRef) + '#' + $id,
                    ...resolvedRef.node,
                };
            },
            logger: false,
        });
        addFormats(ajvInstance); // TODO: fix type mismatch
    }
    return ajvInstance;
}
function getAjvValidator(schema, loc, resolve, allowAdditionalProperties) {
    const ajv = getAjv(resolve);
    const $id = encodeURI(loc.absolutePointer);
    if (!ajv.getSchema($id)) {
        ajv.setDefaultUnevaluatedProperties(allowAdditionalProperties);
        ajv.addSchema({ $id, ...schema }, $id);
    }
    return ajv.getSchema($id);
}
export function validateJsonSchema(data, schema, schemaLoc, instancePath, resolve, allowAdditionalProperties) {
    const validate = getAjvValidator(schema, schemaLoc, resolve, allowAdditionalProperties);
    if (!validate)
        return { valid: true, errors: [] }; // unresolved refs are reported
    const valid = validate(data, {
        instancePath,
        parentData: { fake: {} },
        parentDataProperty: 'fake',
        rootData: {},
        dynamicAnchors: {},
    });
    return {
        valid: !!valid,
        errors: (validate.errors || []).map(beatifyErrorMessage),
    };
    function beatifyErrorMessage(error) {
        let message = error.message;
        const suggest = error.keyword === 'enum' ? error.params.allowedValues : undefined;
        if (suggest) {
            message += ` ${suggest.map((e) => `"${e}"`).join(', ')}`;
        }
        if (error.keyword === 'type') {
            message = `type ${message}`;
        }
        const relativePath = error.instancePath.substring(instancePath.length + 1);
        const propName = relativePath.substring(relativePath.lastIndexOf('/') + 1);
        if (propName) {
            message = `\`${propName}\` property ${message}`;
        }
        if (error.keyword === 'additionalProperties' || error.keyword === 'unevaluatedProperties') {
            const property = error.params.additionalProperty || error.params.unevaluatedProperty;
            message = `${message} \`${property}\``;
            error.instancePath += '/' + escapePointerFragment(property);
        }
        return {
            ...error,
            message,
            suggest,
        };
    }
}
//# sourceMappingURL=ajv.js.map