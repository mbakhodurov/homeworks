const operatorSchema = {
    type: 'string',
    enum: [
        'eq',
        'in',
        'gt',
        'gte',
        'lt',
        'lte',
        'contains',
        'startsWith',
        'endsWith',
        'exists',
        'isEmpty',
        'between',
        'matches',
        'some',
        'every',
        'none',
        'and',
        'or',
        'not',
    ],
};
// Base condition schema with field, operator, value, and match properties
const conditionSchema = {
    type: 'object',
    properties: {
        field: { type: 'string' },
        operator: operatorSchema,
        value: {
            oneOf: [{ type: 'boolean' }, { type: 'string' }, { type: 'number' }],
        },
        match: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    field: { type: 'string' },
                    operator: operatorSchema,
                    value: {
                        oneOf: [{ type: 'boolean' }, { type: 'string' }, { type: 'number' }],
                    },
                },
            },
        },
    },
};
// Schema for a logical operator with conditions (used for nesting)
const logicalOperatorConditionSchema = {
    type: 'object',
    properties: {
        operator: operatorSchema,
        conditions: {
            type: 'array',
            items: conditionSchema, // At the deepest level, only simple conditions
        },
    },
    required: ['operator', 'conditions'],
    additionalProperties: false,
};
// Conditions schema allowing nested conditions with up to 2 levels of recursion
const conditionsSchema = {
    type: 'array',
    items: {
        oneOf: [
            conditionSchema,
            {
                type: 'object',
                properties: {
                    operator: operatorSchema,
                    conditions: {
                        type: 'array',
                        items: {
                            oneOf: [conditionSchema, logicalOperatorConditionSchema],
                        },
                    },
                },
                required: ['operator', 'conditions'],
                additionalProperties: false,
            },
        ],
    },
};
const entityRuleAssertionSchema = {
    type: 'object',
    properties: {
        defined: { type: 'boolean' },
        nonEmpty: { type: 'boolean' },
        eq: {},
        gt: { type: 'number' },
        gte: { type: 'number' },
        lt: { type: 'number' },
        lte: { type: 'number' },
        const: {},
    },
    additionalProperties: false,
};
const entityRuleWhereSchema = {
    type: 'array',
    items: {
        type: 'object',
        properties: {
            subject: {
                type: 'object',
                properties: {
                    type: {
                        type: 'string',
                        enum: ['Entity', 'EntityMetadata', 'EntityRelations', 'EntityRelation'],
                    },
                    property: { type: 'string' },
                },
                required: ['type', 'property'],
                additionalProperties: false,
            },
            assertions: entityRuleAssertionSchema,
        },
        required: ['subject', 'assertions'],
        additionalProperties: false,
    },
};
const entityRuleSchema = {
    type: 'object',
    properties: {
        title: { type: 'string' },
        subject: {
            type: 'object',
            properties: {
                type: {
                    type: 'string',
                    enum: ['Entity', 'EntityMetadata', 'EntityRelations', 'EntityRelation'],
                },
                property: { type: 'string' },
            },
            required: ['type', 'property'],
            additionalProperties: false,
        },
        severity: {
            type: 'string',
            enum: ['error', 'warn', 'off'],
        },
        message: { type: 'string' },
        assertions: entityRuleAssertionSchema,
        where: entityRuleWhereSchema,
        weight: { type: 'number', default: 1 },
    },
    required: ['subject', 'assertions'],
    additionalProperties: false,
};
// Supports both OpenAPI/AsyncAPI rules (backward compatibility) and entity rules
const levelRulesSchema = {
    type: 'object',
    additionalProperties: {
        oneOf: [
            { type: 'string' },
            {
                type: 'object',
                properties: {
                    severity: {
                        type: 'string',
                        enum: ['error', 'warn', 'off'],
                    },
                    weight: { type: 'number', default: 1 },
                },
                additionalProperties: true,
            },
            entityRuleSchema,
        ],
    },
};
const levelSchema = {
    type: 'object',
    properties: {
        name: { type: 'string' },
        extends: {
            type: 'array',
            items: { type: 'string' },
        },
        rules: levelRulesSchema,
    },
    required: ['name'],
    additionalProperties: false,
};
const triggerEventSchema = {
    type: 'object',
    properties: {
        event: {
            type: 'string',
            enum: ['runtime', 'manual'],
        },
    },
    required: ['event'],
    additionalProperties: false,
};
const triggerSchema = {
    oneOf: [
        triggerEventSchema,
        {
            type: 'array',
            items: triggerEventSchema,
        },
    ],
};
export const scorecardSchema = {
    type: 'object',
    properties: {
        name: { type: 'string' },
        description: { type: 'string' },
        entities: {
            oneOf: [
                conditionsSchema,
                {
                    type: 'object',
                    properties: {
                        operator: operatorSchema,
                        conditions: conditionsSchema,
                    },
                    required: ['operator', 'conditions'],
                    additionalProperties: false,
                },
            ],
        },
        levels: {
            type: 'array',
            items: levelSchema,
            minItems: 1,
        },
        trigger: triggerSchema,
    },
    required: ['name', 'entities', 'levels'],
    additionalProperties: false,
};
export const scorecardsConfigSchema = {
    type: 'array',
    items: scorecardSchema,
};
//# sourceMappingURL=scorecards-config-schema.js.map