import { detectSpec, doesYamlFileExist, isPlainObject, logger, HandledError, } from '@redocly/openapi-core';
import { version } from './utils/package.js';
import { loadConfigAndHandleErrors } from './utils/miscellaneous.js';
import { sendTelemetry, collectXSecurityAuthTypes } from './utils/telemetry.js';
import { AbortFlowError, exitWithError } from './utils/error.js';
export function commandWrapper(commandHandler) {
    return async (argv) => {
        const startedAt = performance.now();
        let code = 2;
        let telemetry;
        let specVersion = 'unknown';
        let specKeyword;
        let specFullVersion;
        let config;
        const respectXSecurityAuthTypes = [];
        const collectSpecData = (document) => {
            try {
                specVersion = detectSpec(document);
            }
            catch (err) {
                specVersion = `unsupported`;
            }
            if (!isPlainObject(document))
                return;
            specKeyword = document?.openapi
                ? 'openapi'
                : document?.swagger
                    ? 'swagger'
                    : document?.asyncapi
                        ? 'asyncapi'
                        : document?.arazzo
                            ? 'arazzo'
                            : document?.overlay
                                ? 'overlay'
                                : undefined;
            if (specKeyword) {
                specFullVersion = document[specKeyword];
            }
            else {
                // Ensure specFullVersion is undefined if specKeyword is not found
                specFullVersion = undefined;
            }
            if (specVersion === 'arazzo1') {
                collectXSecurityAuthTypes(document, respectXSecurityAuthTypes);
            }
        };
        try {
            if (argv.config && !doesYamlFileExist(argv.config)) {
                exitWithError('Please provide a valid path to the configuration file.');
            }
            config = await loadConfigAndHandleErrors(argv, version);
            telemetry = config.resolvedConfig.telemetry;
            code = 1;
            if (typeof commandHandler === 'function') {
                await commandHandler({ argv, config, version, collectSpecData });
            }
            code = 0;
        }
        catch (err) {
            if (err instanceof AbortFlowError) {
                // do nothing
            }
            else if (err instanceof HandledError) {
                logger.error(err.message + '\n\n');
            }
            else {
                logger.error('An unexpected error occurred. This is likely a bug that should be reported.\n');
                logger.error(err instanceof Error ? err.stack || err.message : String(err));
                logger.error('\n');
            }
        }
        finally {
            if (process.env.REDOCLY_TELEMETRY !== 'off' && telemetry !== 'off') {
                const executionTime = Math.round(performance.now() - startedAt);
                await sendTelemetry({
                    config,
                    argv,
                    exit_code: code,
                    execution_time: executionTime,
                    spec_version: specVersion,
                    spec_keyword: specKeyword,
                    spec_full_version: specFullVersion,
                    respect_x_security_auth_types: respectXSecurityAuthTypes,
                });
            }
            process.once('beforeExit', () => {
                process.exit(code);
            });
        }
    };
}
//# sourceMappingURL=wrapper.js.map